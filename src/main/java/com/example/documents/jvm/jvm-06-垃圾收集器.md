> 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

# Serial收集器

> 复制算法

Stop The World!
> 单线程收集器，进行垃圾收集时，必须暂停其他所有的工作线程，直到他收集结束。

优点：
> 简单而高效，对于运行在客户端模式下的虚拟机来说是一个很好的选择。
> 依然是HotSpot虚拟机在客户端模式下的默认新生代收集器。

# ParNew收集器

> 复制算法
>
> 其实就是Serial收集器的多线程并行版本，除了使用多条线程进行
> 垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、`Stop The World`
> 、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上也共用了相当多的代码。
>
>

优点：
> 运行在服务端模式下的虚拟机中首选的`新生代`收集器。
>
> **其中一个重要原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。**
>
> 是激活CMS后（-XX:UseConcMarkSweepGC）的默认新生代收集器（也可以使用-XX:+/-UseParNewGC强制指定或禁用，JDK9之后此参数取消）。

# Parallel Scavenge收集器

> 复制算法

> `新生代`收集器，也是使用复制算法的收集器，又是并行的多线程收集器。。。

与其他收集器的不同点
> 其他收集器关注点是尽可能地缩短垃圾收集时时用户线程的停顿时间

> Parallel Scavenge收集器的目的则是：达到一个可控制的`吞吐量`。
>> 所谓的吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）。

提供了两个参数用于精确控制吞吐量

| 参数                   | 说明           |
|----------------------|--------------|
| -XX:MaxGCPauseMillis | 控制最大垃圾收集停顿时间 |
| -XX:GCTimeRatio      | 直接设置吞吐量大小    |

# Serial Old收集器

> 标记-整理算法

> Serial 收集器的`老年代`版本，单线程

主要意义也是在于给在客户端模式下的虚拟机使用

| 服务端模式下的两大用途                                        |
|:---------------------------------------------------|
| 1、在JDK 1.5 以及之前的版本中与Parallel Scavenge收集器搭配使用       |
| 2、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。 |

# Parallel Old 收集器

> 标记-整理算法

> Parallel Scavenge收集器的`老年代`版本，支持多线程并发收集，在JDK 1.6 中才开始提供

在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

# CMS 收集器

> 全称为：Concurrent Mark Sweep

> 标记-清除算法

> 一种以获取最短回收停顿时间为目标的收集器。

适用于在互联网站或B/S系统的服务端上，重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

四个步骤:
> 其中初始标记和重新标记仍然需要`Stop The World`
> 1. 初始标记：标记一下GC Roots能直接关联到的对象
> 2. 并发标记：从GC Roots的直接关联对象开始遍历整个对象图，耗时较长，但是与用户线程并发运行。
> 3. 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
> 4. 并发清除：清理删除掉标记阶段判断的已经死亡的对象。也是与用户线程并发执行的。

优点：
> 并发收集，低停顿

缺点：
> 1. 对CPU资源非常敏感
> 2. 无法处理浮动垃圾
>   > 伴随着程序运行会不断有新的垃圾产生，永远也清理不完。
> 3. 基于“标记-清除”算法，会有大量空间碎片产生

# G1 收集器

整体上是标记-整理算法，局部是标记-复制算法。

> - Garbage-First 收集器是垃圾收集器技术发展历史上的里程碑式的成果。
>- 是一款面向服务端应用的垃圾收集器,HotSpot开发团队最初期望他未来可替换掉JDK5中发布的CMS收集器。
>- JDK9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS沦落为被声明为不推荐使用的收集器。

- 开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。
- `停顿时间模型`的收集器，指能够支持在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。
- 之前的收集器目标范围要么是整个新生代要么是整个老年代，G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection
  Set，简称CSet）进行回收，哪块内存中存放的垃圾最多，回收收益就最大，这就是G1的`Mixed GC`模式。
- G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。
-
G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间，Survivor空间，或者老年代空间。收集器对扮演不同角色的Region采用不同的策略去处理。
- G1中海油一类特殊的Humongous区域，专门用来存储大对象（G1认为只要大小超过一个Region容量一半的对象即可判定为大对象）。

G1的运作过程：

- 初始标记：标记一下GC Roots能直接关联到的对象并且修改TAMS指针的值，让下一阶段用户线程并发运行时能正确地在可用的Region中分配新对象。
- 并发标记：从GC Roots开始对堆中对象进行可达性分析，扫描整个堆里的对象图，找出要回收的对象，耗时长，可与用户线程并发执行。完成后还要重新处理STAB记录下的在并发时有引用变动的对象。
- 最终标记：对用户线程做另一个短暂的停顿，用于处理并发阶段结束后仍遗留下来的最后那少量的STAB记录。
-
筛选回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，将Region中的存活对象复制到空的Region中，清理掉整个旧的Region。必须暂停用户线程，多条收集器线程并行完成。

# 低延迟垃圾收集器

## Shenandoah收集器

一款只有OpenJDK才包含，OracleJDK里不存在的收集器。
最初是由RedHat公司独立发展的新型收集器项目。2014年贡献给了OpenJDK，并推动他成为OpenJDK 12的正式特性之一。

目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器。

## ZGC收集器

一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器。

目标和Shenandoah高度相似，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。

# 并行与并发
<font color=54,186,196>
并行：描述的是多条垃圾收集器线程之间的关系。

并发：描述的是垃圾收集器线程和用户线程之间的关系
</font>
# 总结
## JDK默认垃圾收集器

| JDK版本 | 默认的垃圾收集器                         |
|-------|----------------------------------|
| 1.7   | Parallel Scavenge + Parallel Old |
| 8     | Parallel Scavenge + Parallel Old |
| 9     | G1                               |

## 垃圾收集器对比

| 垃圾收集器             | 算法                      | 特点        | 适用场景  | 说明                                                                                                       |
|-------------------|:------------------------|:----------|-------|----------------------------------------------------------------------------------------------------------|
| Serial            | 复制                      | 单线程、新生代   | 客户端模式 | HotSpot虚拟机在客户端模式下默认的新生代收集器                                                                               |
| ParNew            | 复制                      | 多线程并行、新生代 | 服务端模式 | 除了Serial外，唯一能与CMS配合工作的，也是激活CMS后默认的新生代收集器                                                                 |
| Parallel Scavenge | 复制                      | 多线程并行、新生代 | 服务端模式 | 吞吐量优先                                                                                                    |
| Serial Old        | 标记-整理                   | 单线程、老年代   | 客户端模式 | 服务端模式下用途：1、在JDK 1.5 以及之前的版本中与Parallel Scavenge收集器搭配使用；2、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。 |
| Parallel Old      | 标记-整理                   | 多线程并发、老年代 | 服务端模式 | 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。                                         |
| CMS               | 标记-清除                   | 多线程并发、老年代 | 服务端模式 | 并发收集、低停顿；                                                                                                |
| G1                | 标整体上是标记-整理算法，局部是标记-复制算法 | 多线程并发、老年代 | 服务端模式 | 开创了收集器面向局部收集的设计思路和基于Region的内存布局形式；JDK9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器       |

![](http://www.ffeiyang.top/jvm-garbage-collectior.png)