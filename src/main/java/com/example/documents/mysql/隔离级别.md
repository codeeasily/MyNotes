# 四种隔离级别
- READ UNCOMMITTED(未提交读)
  > 事务中的修改即便没有提交，对其他事务也是可见的。
  >
  > 事务可以读取未提交的数据，被称为`脏读`。
- READ COMMITTED(提交读)
  > 大多数数据库的默认隔离级别（MySQL不是）。
  > 
  > 一个事务开始时，自能看见已经提交的事务所做的修改。换句话说就是一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。
  > 
  > 也叫不可重复读，两次执行同样的查询，可能会得到不一样的结果。
- REPEATABLE READ(可重复读)
  > MySQL的默认隔离级别。
  > 
  > 解决了脏读的问题。保证了同一个事务中多次读取同样记录的结果是一致的。但是么有解决幻读的问题。
  >
  > 幻读：指的是当某个事务在读取某个范围内的记录的时候，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
  >
  > InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。
- SERIALIZABLE(可串行化)
  > 最高的隔离级别。通过强制事务串行执行，避免幻读的问题。会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
  >
  > 实际应用中很少用。

# 死锁
两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

- 当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。
- 多个事务同时锁定同一资源时，也会产生死锁。

目前InnoDB处理死锁的方法是：将持有最少行级排它锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

# 多版本并发控制（MVCC）
MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都实现了多版本并发控制（MVCC）。

MVCC是行级锁的一个变种，他在很多情况下避免了加锁的操作，因此开销更低，大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能不一样。

典型的有乐观并发控制和悲观并发控制。

## InnoDB的MVCC：
是通过在每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。存储的并不是实际的时间值，而是系统版本号。

每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

MVCC只在REPEATABLE READ 和 READ COMMITTED两个隔离级别下工作。