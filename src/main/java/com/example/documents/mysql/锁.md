# 读写锁
共享锁(S)和排它锁(X)，也叫读锁和写锁。

读锁是共享的，或者说是相互不阻塞的。多个客户同一时刻可以同时读取同一个资源，而互不干扰。

写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定的时间里，只有一个用户可以写入，并防止其他用户读取正在写入的同意资源。
# 锁粒度
- 表锁
  > 最基本的锁策略，也是开销最小的策略。
- 行级锁
  > 行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。

# InnoDB锁问题
## InnoDB的行锁模式和加锁方法
InnoDB实现了以下两种类型的锁：
- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
- 排它锁（X）：允许获得排它锁的事务更新数据，阻止其他事务获得相同数据集的共享读锁和排他写锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁：
- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先获得该表的IS锁。
- 意向排它锁（IX）：事务打算给数据行加行排它锁，事务在给一个数据行加排它锁前必须先获得该表的IX锁。

| 请求锁模式/是否兼容/当前锁模式 | X   | IX  | S   | IS  |
|------------------|-----|-----|-----|-----|
| X                | 冲突  | 冲突  | 冲突  | 冲突  |
| IX               | 冲突  | 兼容  | 冲突  | 兼容  |
| S                | 冲突  | 冲突  | 兼容  | 兼容  |
| IS               | 冲突  | 兼容  | 兼容  | 兼容  |
如果一个事务请求的锁模式与当前的兼容，就将请求的锁授予该事务，否则该事务要等待锁释放。

意向锁是InnoDB自动加的，不需要用户干预。
## InnoDB行锁实现方式
通过给索引上的索引项加锁来实现的，如果没有索引，将通过隐藏的聚簇索引来对记录加锁。

分为三种情形：
- Record lock: 对索引项加锁。
- GAP lock：对索引项之间的"间隙"、第一条记录前的"间隙"或最后一条记录后的"间隙"加锁。
- Next-key lock：前两种的组合，对记录及其前面的间隙加锁。

这种行锁实现特点意味着：**如果不通过索引条件检索数据，那么将对表中的所有记录加锁，实际效果跟表锁一样。**

实际应用中需注意：
- 在不通过索引条件查询时，InnoDB会锁定表中的所有记录。
- 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候需要注意。
- 当表中有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
- 即使在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，就不会使用索引，这种情况下也会对所有记录加锁。因此分析锁冲突时，别忘了检查SQL的执行计划，确认是否真正使用了索引。
