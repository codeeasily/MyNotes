# InnoDB存储引擎
MySQL的默认事务引擎。被设计用来处理大量的短期事务。短期事务大部分情况是正常提交的，很少被回滚。

InnoDB的性能和自动崩溃恢复特性，使得在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否二应该优先考虑InnoDB引擎。

InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，有一系列的数据文件组成。

InnoDB采用MVCC来支持高并发，默认级别可重复读。并且通过间隙锁策略防止幻读的出现。间隙锁使得InnoDB不仅锁定查询的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
# MyISAM存储引擎
MySQL 5.1及之前的版本，默认存储引擎是MyISAM。

提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但是不支持事务和行级锁。崩溃后无法安全恢复。

# MySQL内建的其他存储引擎
## Archive引擎
- 只支持INSERT和SELECT操作。MySQL 5.1之前不支持索引。
- 会缓存所有的写并利用zlib对插入的行进行压缩，所以比MyISAM表的磁盘I/O更少。
- 每次SELECT都会全表扫描，所以Archive表适合日志和数据采集类应用，或者一些需要更快速INSERT操作的场合下
## Blackhole引擎
没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但是服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者只是简单地记录到日志。
## CSV引擎
可以将普通的CSV文件（逗号分割值的文件）作为MySQL的表来处理。但是不支持索引。可以作为一种数据交换的机制，非常有用。
## Federated引擎
是访问其他MySQL服务器的一个代理，它会创建一个到远程MySQL服务器的客户端链接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。默认是禁用的。
## Memory引擎
如果需要更快的访问，并且这些数据不会被修改，重启以后丢失也没有关系，则可以使用Memory表（以前也叫HEAP表）。

数据都保存在内存中。结构在重启以后会保留，但是数据会丢失。

支持哈希索引。

表级锁，并发写入性能较低。

不支持BLOB或TEXT类型的列，并且每行的长度是固定的，可能会导致部分内存的浪费。

如果MySQL在执行查询的时候需要使用临时表来保存中间结果，内部使用的临时表就是Memory表。如果中间结果太大超出了Memory表的限制，
或者含有BOLB或TEXT类型的字段，则临时表会转为MyISAM表。

场景：
- 用于查找或者映射表，例如将邮编和地区映射的表。
- 用于缓存周期性聚合数据的结果。
- 用于保存数据分析中产生的中间数据。
## Merge引擎
是MyISAM引擎的一个变种。由多个MyISAM表合并而来的虚拟表。适用于日志或数据仓库类应用。引入分区功能后，该引擎已被放弃。
## NDB集群引擎
2003年，当时的MySQL AB公司从索尼爱立信公司收购了NDB数据库，然后开发了NDB集群存储引擎，作为SQL和NDB原生协议之间的接口。

MySQL服务器，NDB集群存储引擎，以及分布式的、share-nothing的、容灾的、高可用的NDB数据库的集合，被称为MySQL集群。
# 第三方存储引擎
## OLTP类引擎
- XtraDB
  > Percona的`XtraDB`存储引擎是基于InnoDB引擎的一个改进版本。改进点主要集中在性能、可测量性和操作灵活性方面。
- TokuDB
  > 使用了一种新的叫做分形树的索引数据结构，该结构是缓存无关的。即使其大小超过内存性能也不会下降，也就没有内存声明周期和碎片的问题。
  > 
  > 是一种大数据存储引擎。最适合在需要大量插入数据的分析型数据集的场景中使用。
  >
  > 处于生产早起版本状态，并发性方面还有很多明显的限制。
- RethinkDB
  > 最初是为固态存储（SSD）设计的，特别的地方在于采用了一种只能追加的写时复制B树作为索引的数据结构。
## 面向列的存储引擎
MySQL默认是面向行的，每一行的数据是一起存储的，查询也是以行为单位的。

大数据量处理时，面向列的方式可能效率更高。如果不需要整行的数据，面向列的方式可以传输更少的数据。如果每一列都单独存储，那么压缩的效率也会更高。

- `Infobright`
  > 是最有名的面向列的存储引擎。在非常大的数据量（数十TB）时，该引擎工作良好。
  > 是为数据分析和数据仓库应用设计的。
## 社区存储引擎
只有极少数人在用，大都没有在生产环境中应用过，慎用，后果自负。
- Aria
  > 之前的名字是Maria，是MySQL创建者计划用来替代MyISAM的一款引擎。可以说是解决了崩溃安全恢复的MyISAM，也有一些新特性是MyISAM不具备的，比如数据的缓存（MyISAM只能缓存索引）
- Groonga
  > 一款全文索引引擎，号称可以提供准确而高效的全文索引。
- Q4M
  > 在MySQL内部实现了队列操作。
- SphinxSE
  > 为Sphinx全文索引搜索服务器提供了SQL接口
- Spider
  > 可以将数据切分成不同的分区，比较高效透明的实现了分片，并且可以针对分片执行并行查询。


# 转换表的存储引擎
- ALTER TABLE
  > 将表从一个引擎修改为另一个引擎最简单的办法。
  > 
  > mysql> ALTER TABLE mytable ENGINE = InnoDB;
  > 
  > - 适用于任何存储引擎
  > - 需要执行很长时间（MySQL会按行将数据从原表中复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。）
  > - 转换表的引擎会时区和原引擎相关的所有特性。如InnoDB表转为MyISAM表，再转回InnoDB，所有外键将丢失。
- 导入与导出
  > 为更好的控制转换的过程，可以使用`mysqldump`工具将数据导出到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，同时修改表名，因为同一数据库中不能存在相同的表名。
  > 同时要注意`mysqldump`默认会自动在CREATE TABLE语句前加上DROP TABLE语句。
- 创建与查询
  > 综合了第一种的高效和第二种方法的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用INSERT...SELECT语法来导数据。
  > 
  > mysql> CREATE TABLE innodb_table LIKE myisam_table; 
  > mysql> ALTER TABLE innodb_table ENGINE=InnoDB;
  > mysql> INSERT INTO innodb_table SELECT * FROM myisam_table;
  